\chapter{Implementacja systemu}
\thispagestyle{chapterBeginStyle}
W tym rozdziale opisane zostały aspekty implementacyjne takie jak wzorzec architektoniczny aplikacji, narzędzia użyte do stworzenia aplikacji i ciekawe problemy napotkane podczas tworzenia serwisu.
\section{Implementacja  wzorca  MVC}
Opis implementacji wzorca projektowego MVC podzielony został na przedstawienie modelu, widoku i kontrolera.
\paragraph{Model}

Model reprezentowany jest przez model w bazie danych oraz przez serwisy na serwerze. 
Każda tabela posiada swój serwis. Jest to komponent, który odpowiedzialny jest za odpowiednie wprowadzanie i wyciąganie potrzebnych informacji z tabeli, którą reprezentują. Model został opisany wraz z przedstawieniem projektu bazy danych 
\paragraph{View - Widok}


Widok zaimplementowany jest przy pomocy szkieletu architektonicznego Angular korzystającego z HTML oraz TypeScript. Podstawowym obiektem w szkielecie jest komponent, na który składa się również skryptowy plik html i css lub scss. Komponent jest definicją jednego z wielu widoków w aplikacji, które \textit{Angular} przedstawia na głównej stronie. Dużą rolę podczas implementacji widoku tworzy moduł \textit{ReactiveForms}. Jest to zbiór pomocniczych komponentów udostępnianych przez biblioteki szkieletu \textit{Angular}, które służą do budowania formularzy. Otrzymywanie wiadomości od użytkownika polega na wyświetlaniu formularzy z polami, które wspólnie tworzą szkielet obiektu. Dane wprowadzone przez użytkownika do formularza są treścią zapytania do bazy danych o stworzenie lub zaktualizowanie informacji.  Przykładowe widoki z wcześniejszego rozdziału takie jak dodanie tablicy ~\ref{addb}, szczegóły zadania ~\ref{taskcomm}, czy sam proces logowania ~\ref{login-state}, polegają głównie na przedstawieniu formularzu do wypełniania dla klienta.
\paragraph{Controller - Kontroler}


Kontroler zaimplementowany jest głównie po stronie serwera, lecz komponenty odpowiedzialne za widok posiadają w sobie wstępne modyfikacje na danych otrzymanych od użytkownika takie jak przykładowo walidacja tych danych. Zaletą podejścia, aby funkcje kontrolera spełniane były po otrzymaniu jakichkolwiek danych jest to, że informacje, które przychodzą do serwera, aby przeszły przez główną logikę serwera są danymi nie podatnymi na błędy, więc serwer odpowiedzialny za logikę, nie będzie musiał skupiać się na odsyłaniu błędnych danych z powrotem do widoku, a o wiele częściej będzie otrzymywać już poprawne dane. Wadą takiego podejścia jest większe skomplikowanie w kodzie, ponieważ walidacja odbywa się wtedy zarówno na serwerze jak i po stronie klienta. Aplikacja odpowiedzialna za widoku musi również posiadać wiedzę na temat modelu bazy danych i poszczególne cechy różnych danych, aby odpowiednia logika mogła zostać zastosowana.


\section{Użyte technologie}
Projekt w pełni kompatybilny z systemem Windows 10 wykorzystuje z najważniejszych technologii:
\begin{itemize}
	\item Java 11
	\item Angular 11
	\item Bootstrap 4.6
	
\end{itemize}
W języku programowania Java pomocniczą technologią jest szkielet architektoniczny Spring. Posiada on dużo przeróżnych gałęzi i jest najpopularniejszym pomocniczym narzędziem dla języka Java. Aplikacja TaskManager korzysta z gałęzi Spring Boot, Spring Security oraz Spring Data JPA. 

\textit{Spring Security} zapewnia odpowiednie klasy wspomagające konfigurację autoryzacji i kontroli dostępu do zaimplementowanego serwera. \cite{SpringSecurity}   

\textit{Spring Data JPA} ułatwia dostęp do bazy danych udostępniając potrzebne metody wyciągające odpowiednie informacje z bazy danych.\cite{SpringData}  

\textit{Spring Boot} to gałąź, która pomaga ze wszystkimi możliwościami tego szkieletu i konfiguruje aplikację. 
W tym celu korzystając z narzędzia Spring Boot Initializer \cite{SpringInitializr} cały szkielet projektu został zainicjalizowany i udostępniony do pobrania.
Kolejnym z ważnych narzędzi pomocniczych użytych podczas implementacji serwera jest \textit{package manager Maven}. Jest to narzędzie, które ułatwia zarządzanie projektem, ujednolica budowanie i kompilowanie zaawansowanego projektu napisanego w języku Java \cite{ApacheMavenProject}. 

\section{Narzędzia pomocnicze i środowisko programistyczne }
Program napisany został przy pomocy \textbf{Inteliij IDEA} . Jest to środowisko programistyczne, które w pełni wspomaga pisanie dużych projektów w języku Java. Możliwość debugowania kodu i pomocne wtyczki, które przykładowo pomagają utrzymać czystość kodu to ważny element podczas tworzenia aplikacji.
Kolejnym niezbędnym narzędziem jest \textbf{Postman }, który pomaga testować zapytania do serwerowego API. Aby zobaczyć, czy widok otrzymuje odpowiednie dane od serwera, wymagane jest przetestowanie zapytań, w tym celu zamiast wywoływać je ręcznie w aplikacji, wykorzystujemy dany program, w którym przybieramy rolę klienta serwera i wysyłamy odpowiednie zapytania, oczekując prawidłowych odpowiedzi \cite{Postman}.
Cały projekt znajdował się podczas produkcji kodu w systemie kontroli wersji Git, w celu ułatwionego dostępu i możliwości powrotu do różnych wersji projektu\cite{git}.


\section{Opis ważniejszych  implementacji}

\subsection{Bezpieczeństwo aplikacji}
\subsubsection{konfiguracja}
Klasa \textit{SecurityConfiguration} przetrzymuje konfiguracje związane z odpowiednim dostępem w zależności od pozwoleń zalogowanego użytkownika. Na przedstawionym fragmencie kodu~\ref{httpconfig} prawie wszystkie ścieżki udostępnione są dla każdej roli poza ścieżkami \textit{api/admin/**} i \textit{management/**}, do których dostęp ma jedynie użytkownik z rolą administratora

\subsubsection{Autoryzacja i tworzenie konta}
Tworzenie konta użytkownika polega na wprowadzeniu potrzebnych informacji takich jak login, hasło i e-mail. Po zaakceptowaniu danych przez serwer stworzona zostaje encja użytkownika nieaktywnego. Generowany zostaje klucz, który wysyłany jest w postaci linka na podaną wcześniej skrzynkę pocztową. Po wejściu w odpowiednią ścieżkę przez link z wiadomości użytkownik aktywuje konto i może się zalogować~\ref{register}

\clearpage
\begin{lstlisting} [ caption= Uproszczona metoda określająca dostęp do podanych ścieżek, captionpos=b, label={httpconfig}]
	http
	.authorizeRequests()
	.antMatchers("/api/**").permitAll()
	.antMatchers("/api/admin/**").hasAuthority(AuthoritiesConstants.ADMIN)
	.antMatchers("/api/**").authenticated()
	.antMatchers("/management/**").hasAuthority(AuthoritiesConstants.ADMIN);
\end{lstlisting}


\begin{lstlisting} [ caption= Metoda rejestrująca użytkownika , captionpos=b, label={register}]
	public User registerUser(AdminUserDTO userDTO, String password) {
		
		User newUser = new User();
		String encryptedPassword = passwordEncoder.encode(password);
		newUser.setLogin(userDTO.getLogin().toLowerCase());
		// new user gets initially a generated password
		newUser.setPassword(encryptedPassword);
		newUser.setFirstName(userDTO.getFirstName());
		newUser.setLastName(userDTO.getLastName());
		if (userDTO.getEmail() != null) {
			newUser.setEmail(userDTO.getEmail().toLowerCase());
		}
		newUser.setImageUrl(userDTO.getImageUrl());
		newUser.setLangKey(userDTO.getLangKey());
		// new user is not active
		newUser.setActivated(false);
		// new user gets registration key
		newUser.setActivationKey(generateRandomAlphanumericString());
		Set<Authority> authorities = new HashSet<>();
		authorityRepository.findById(AuthoritiesConstants.USER)
		.ifPresent(authorities::add);
		newUser.setAuthorities(authorities);
		userRepository.save(newUser);
		log.debug("Created Information for User: {}", newUser);
		return newUser;
	}
\end{lstlisting}
\clearpage
\subsection{Tablica przeciągnij i upuść}
Główny widok aplikacji to tablica, na której użytkownik jest w stanie za pomocą wydarzenia przyciskiem myszy przeciągnij i upuść (z angielskiego drag and drop), aktualizować zadania do odpowiedniej kolumny. W tym celu użyty został moduł z Angulara o nazwie DragDropModule \cite{draganddrop}. Posiada on opisane dyrektywy o określonych funkcjach takich jak:
\begin{itemize}
	\item cdkDrag - nadaje elementom możliwość przeciągnięcia,
	\item cdkDropList - element ten określa listę elementów \textit{cdkDrop}, który odpowiednio je sortuje i jest w stanie wywołać wydarzenie wprowadzenia nowego elementu \textit{cdkDropListDropped},
	\item cdkDropListGroup - jako rodzic elementów \textit{cdkDropList} ma możliwość połączenia wszystkich elementów \textit{cdkDropList}, aby mogły one współdzielić wszystkie elementy  \textit{cdkDrop}, dzięki czemu możliwe jest  przeniesienie elementu \textit{cdkDrop}  z \textit{cdkDropList} A do \textit{cdkDropList} B
\end{itemize}
Na załączonym uproszczonym kodzie źródłowym ~\ref{board} kontener \textit{div tasks-container} zawiera wszystkie elementy, które przypisane mają do siebie zadania. Wydarzenie przeciągnięcia zadania na jedną z list wywołuje metodę \textit{drop}, która zapisuje identyfikatory odpowiednio zadania przeciąganego, kolumny z którego zadanie zostało przeciągnięte oraz kolumny, do której przeciągnięto dany element.


\begin{lstlisting} [ caption= Uproszczony skrypt odpowiedzialny za widok tablicy , captionpos=b, label={board}]
	<div class="board-columns" cdkDropListGroup>
	  <div class="board-column" *ngFor="let column of cards">
	    <div class="tasks-container"
	     cdkDropList
	     [cdkDropListData]="column.tasks"
	     (cdkDropListDropped)="drop($event)">	
	      <div class="task" id="{{task.id}}" 
                *ngFor="let task of column.tasks" 
                (click)="showTask(task)" 
                [cdkDragDisabled]="task.completed" cdkDrag>
                <span class="task-child" >{{task.name}}</span>
	      </div>
	    </div>
	  </div>
	</div>
\end{lstlisting}
\clearpage
\subsection{Rysowanie wykresów}
Ważnym elementem aplikacji jest widok statystyk przedstawianych w postaci wykresów. Do rysowania wykresów użyta została biblioteka Angular Bootstrap 4 Charts. Biblioteka udostępnia nam dyrektywę \textit{mdbChart},
która to po podaniu odpowiednich parametrów rysuje wykres na kanwie. \cite{MdbAngularBootstrap} Potrzebne parametry to:
\begin{itemize}
	\item chartType typ wykresu, podczas implementacji użyty został typ kołowy chartType = "pie" i liniowy chartType = "line"
	\item datasets to atrybut odpowiedzialny za dane przedstawione na wykresie. Jest to podpisana tytułem lista wartości.
	\item labels to lista nazewnictwa wartości osi poziomej x
	\item colors lista określająca kolory poszczególnych grup wartości
	\item options to lista szczegółowych opcji dostępnych dla wykresu
\end{itemize}
Kod źródłowy przedstawia inicjalizacje wykresu ~\ref{wykres}. Dane pobierane są z bazy danych z trzech nierelacyjnych tabel, które przetrzymują datę i użytkownika wykonującego akcje takie jak przeniesienie zadania z kolumny A do kolumny B, zakończenie zadania czy też przypisanie go do jakiegoś użytkownika. Na podstawie tych tabel inicjalizowana jest lista wartości. Na stronie \textit{statistics} znajdują się cztery typy wykresów:
\begin{itemize}
	\item kołowy wykres przedstawiający postęp w projekcie dzieląc zadania na zrobione, przypisane i nieprzypisane
	\item kołowy wykres, który przedstawia liczbę zadań dla każdej kolumny
	\item liniowy wykres, który dla wymienionego w liście do wybrania zadania pokazuje w ostatnich sześciu miesiącach liczbę przenosin na tablicy oraz liczbę przydzieleń do użytkowników
	\item liniowy wykres dla każdego użytkownika pokazujący liczbę przydzieleń dla ostatnich sześciu miesięcy i liczbę zadań zakończonych
\end{itemize}


\begin{lstlisting} [ caption= Inicjalizacja wykresu , captionpos=b, label={wykres}]
	<div style="display: block; width: 60%;">
	<canvas mdbChart
	[chartType]="chartType"
	[datasets]="chartDatasets"
	[labels]="chartLabels"
	[colors]="chartColors"
	[options]="chartOptions"
	[legend]="true"
	(chartHover)="chartHovered($event)"
	(chartClick)="chartClicked($event)">
	</canvas>
	</div>
\end{lstlisting}
